<!doctype html>


<html    lang="zh-cn" >
    <head>
    
    <meta charset="utf-8">



    <meta content="cpu_security" name="keywords">

<meta content="#0d6efd" name="msapplication-TileColor">

<meta content="#0d6efd" name="theme-color">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta property="og:title" content="MSR security" />
<meta property="og:description" content="摘要 在给cpu添加新特性时，cpu制造商引入一个受限的cpu配置手段（model-specific registers&mdash;MSR）来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/finding-and-exploiting-cpu-features-using-msr-templating/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-01-29T12:29:25+08:00" />
<meta property="article:modified_time" content="2023-01-29T12:29:25+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MSR security"/>
<meta name="twitter:description" content="摘要 在给cpu添加新特性时，cpu制造商引入一个受限的cpu配置手段（model-specific registers&mdash;MSR）来"/>


    <title>MSR security · Cheese - A wonderful world for you</title>
    <link href="/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">

<link href="/favicon.png" rel="icon" type="image/png">
<link href="/favicon.svg" rel="icon" type="image/svg+xml">
<link color="#0d6efd" href="/safari-pinned-tab.svg" rel="mask-icon">
<link href="/site.webmanifest" rel="manifest">








    


<link  crossorigin="anonymous"  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css" integrity=""  referrerpolicy="no-referrer"  rel="stylesheet">









    
    
    


<link  crossorigin="anonymous"  href="/bootstrap.min_11254274094227627370.min.9e0a1d275ddeb92360d4b48d8190962b9d8b1c347856c3931e15d54f308ecfcb.css" integrity="sha256-ngodJ13euSNg1LSNgZCWK52LHDR4VsOTHhXVTzCOz8s="  referrerpolicy="no-referrer"  rel="stylesheet">




    <style>
body, html {
    height: 100%;
}

section[class="paige-content"] {
    counter-reset: paige-figure;
    max-width: 100%;
}

section[class="paige-content"] figure.paige-figure.paige-figure-numbered {
    counter-increment: paige-figure;
}

section[class="paige-content"] figure.paige-figure.paige-figure-numbered figcaption:empty::before {
    content: " " counter(paige-figure);
}

section[class="paige-content"] figure.paige-figure.paige-figure-numbered figcaption::before {
    content: " " counter(paige-figure) ": ";
}

section[class="paige-content"] > blockquote {
    padding: 0.5rem 1rem;
    border-left: 0.25rem solid var(--bs-border-color);
    padding-right: 0.25rem;
}

section[class="paige-content"] > blockquote p:last-of-type {
    margin-bottom: 0;
}





.paige-figure .highlight .chroma pre,
.paige-figure .highlight pre.chroma {
    margin-bottom: 0;
}

.highlight .chroma .lnt,
.highlight .chroma .hl {
    display: flex;
}

.paige-figure > div > div[class="highlight"] > pre, .paige-figure > div > :last-child {
    margin-bottom: 0;
}

.paige-header-link {
    margin-left: 0.5ch;
    opacity: 0;
    position: absolute;
    text-decoration: none;
    transition: color 0.15s ease-in-out, opacity 0.15s ease-in-out;
}

@media (prefers-reduced-motion: reduce) {
    .paige-header-link {
        transition: none;
    }
}

.paige-header-link:focus, .paige-header-link:hover, :hover > .paige-header-link, :target > .paige-header-link {
    opacity: 1;
}


    @media (prefers-color-scheme: dark) {
        /* Background */ .bg { color: #c9d1d9; background-color: var(--bs-body-bg); }
/* PreWrapper */ .chroma { color: #c9d1d9; background-color: var(--bs-body-bg); }
/* Other */ .chroma .x {  }
/* Error */ .chroma .err { color: #f85149 }
/* CodeLine */ .chroma .cl {  }
/* LineLink */ .chroma .lnlinks { outline: none; text-decoration: none; color: inherit }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; }
/* LineHighlight */ .chroma .hl { background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #64686c }
/* LineNumbers */ .chroma .ln { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #6e7681 }
/* Line */ .chroma .line { display: flex; }
/* Keyword */ .chroma .k { color: #ff7b72 }
/* KeywordConstant */ .chroma .kc { color: #79c0ff }
/* KeywordDeclaration */ .chroma .kd { color: #ff7b72 }
/* KeywordNamespace */ .chroma .kn { color: #ff7b72 }
/* KeywordPseudo */ .chroma .kp { color: #79c0ff }
/* KeywordReserved */ .chroma .kr { color: #ff7b72 }
/* KeywordType */ .chroma .kt { color: #ff7b72 }
/* Name */ .chroma .n {  }
/* NameAttribute */ .chroma .na {  }
/* NameBuiltin */ .chroma .nb {  }
/* NameBuiltinPseudo */ .chroma .bp {  }
/* NameClass */ .chroma .nc { color: #f0883e; font-weight: bold }
/* NameConstant */ .chroma .no { color: #79c0ff; font-weight: bold }
/* NameDecorator */ .chroma .nd { color: #d2a8ff; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #ffa657 }
/* NameException */ .chroma .ne { color: #f0883e; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #d2a8ff; font-weight: bold }
/* NameFunctionMagic */ .chroma .fm {  }
/* NameLabel */ .chroma .nl { color: #79c0ff; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #ff7b72 }
/* NameOther */ .chroma .nx {  }
/* NameProperty */ .chroma .py { color: #79c0ff }
/* NameTag */ .chroma .nt { color: #7ee787 }
/* NameVariable */ .chroma .nv { color: #79c0ff }
/* NameVariableClass */ .chroma .vc {  }
/* NameVariableGlobal */ .chroma .vg {  }
/* NameVariableInstance */ .chroma .vi {  }
/* NameVariableMagic */ .chroma .vm {  }
/* Literal */ .chroma .l { color: #a5d6ff }
/* LiteralDate */ .chroma .ld { color: #79c0ff }
/* LiteralString */ .chroma .s { color: #a5d6ff }
/* LiteralStringAffix */ .chroma .sa { color: #79c0ff }
/* LiteralStringBacktick */ .chroma .sb { color: #a5d6ff }
/* LiteralStringChar */ .chroma .sc { color: #a5d6ff }
/* LiteralStringDelimiter */ .chroma .dl { color: #79c0ff }
/* LiteralStringDoc */ .chroma .sd { color: #a5d6ff }
/* LiteralStringDouble */ .chroma .s2 { color: #a5d6ff }
/* LiteralStringEscape */ .chroma .se { color: #79c0ff }
/* LiteralStringHeredoc */ .chroma .sh { color: #79c0ff }
/* LiteralStringInterpol */ .chroma .si { color: #a5d6ff }
/* LiteralStringOther */ .chroma .sx { color: #a5d6ff }
/* LiteralStringRegex */ .chroma .sr { color: #79c0ff }
/* LiteralStringSingle */ .chroma .s1 { color: #a5d6ff }
/* LiteralStringSymbol */ .chroma .ss { color: #a5d6ff }
/* LiteralNumber */ .chroma .m { color: #a5d6ff }
/* LiteralNumberBin */ .chroma .mb { color: #a5d6ff }
/* LiteralNumberFloat */ .chroma .mf { color: #a5d6ff }
/* LiteralNumberHex */ .chroma .mh { color: #a5d6ff }
/* LiteralNumberInteger */ .chroma .mi { color: #a5d6ff }
/* LiteralNumberIntegerLong */ .chroma .il { color: #a5d6ff }
/* LiteralNumberOct */ .chroma .mo { color: #a5d6ff }
/* Operator */ .chroma .o { color: #ff7b72; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #ff7b72; font-weight: bold }
/* Punctuation */ .chroma .p {  }
/* Comment */ .chroma .c { color: #8b949e; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #8b949e; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #8b949e; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #8b949e; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #8b949e; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #8b949e; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #8b949e; font-weight: bold; font-style: italic }
/* Generic */ .chroma .g {  }
/* GenericDeleted */ .chroma .gd { color: #ffa198; background-color: #490202 }
/* GenericEmph */ .chroma .ge { font-style: italic }
/* GenericError */ .chroma .gr { color: #ffa198 }
/* GenericHeading */ .chroma .gh { color: #79c0ff; font-weight: bold }
/* GenericInserted */ .chroma .gi { color: #56d364; background-color: #0f5323 }
/* GenericOutput */ .chroma .go { color: #8b949e }
/* GenericPrompt */ .chroma .gp { color: #8b949e }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #79c0ff }
/* GenericTraceback */ .chroma .gt { color: #ff7b72 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #6e7681 }

    }

    @media (prefers-color-scheme: light) {
        /* Background */ .bg { background-color: #ffffff; }
/* PreWrapper */ .chroma { background-color: #ffffff; }
/* Other */ .chroma .x {  }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* CodeLine */ .chroma .cl {  }
/* LineLink */ .chroma .lnlinks { outline: none; text-decoration: none; color: inherit }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; }
/* LineHighlight */ .chroma .hl { background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* LineNumbers */ .chroma .ln { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* Line */ .chroma .line { display: flex; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* Name */ .chroma .n {  }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameFunctionMagic */ .chroma .fm {  }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameOther */ .chroma .nx {  }
/* NameProperty */ .chroma .py {  }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* NameVariableMagic */ .chroma .vm {  }
/* Literal */ .chroma .l {  }
/* LiteralDate */ .chroma .ld {  }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Punctuation */ .chroma .p {  }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* Generic */ .chroma .g {  }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

    }

</style>

    
</head>

    <body class="d-flex flex-column">

        
        <div class="container flex-fill">
            <div class="row">
                <div class="col">
                    




    <header>
        
        
            





    



    


<nav class="justify-content-center my-3 navbar navbar-expand-sm">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#paige-menu-toggler" aria-controls="paige-menu-toggler" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse justify-content-center mt-3 mt-sm-0 navbar-collapse" id="paige-menu-toggler">
        <div class="align-items-center flex-column flex-sm-row justify-content-center nav  nav-pills ">
            
                
                
                
                <a  class=" nav-link" href="/">Home</a>
            
                
                
                
                <a  aria-current="page"  class=" active   nav-link" href="/post/">Archives</a>
            
                
                
                
                <a  class=" nav-link" href="/tags/">Tags</a>
            
                
                
                
                <a  class=" nav-link" href="/categories/">Categories</a>
            
        </div>
    </div>
</nav>

        
        
    </header>


                    <main>
                        
                        
<article>
    <div class="align-items-center d-flex flex-column mb-0">
        <section class="paige-metadata w-100">
    
    
    

    <h1 class="display-5 fw-bold text-center">MSR security</h1>


    

    





    <p class="text-center text-secondary">
        <time datetime="2023-01-29">January 29, 2023</time>
    </p>


</section>

        

        
    

    <section class="paige-content">
        
        
            <h2 id="摘要">摘要<a aria-label="Link to this section" class="paige-header-link" href="#摘要">#</a></h2>
<p>在给cpu添加新特性时，cpu制造商引入一个受限的cpu配置手段（model-specific registers&mdash;MSR）来保证处理器的后向兼容。MSR种类繁多，提供很多特性，比如调试、性能监控和一些安全保障。目前来看，许多MSR被document了，但是仍然存在大量的MSR没有被document，或者document的不完全（指该MSR寄存器的某些bit没有被document）。因此，在数以百计的MSR（每个提供多达64比特的配置选项）中，寻找特定的配置项是乏味的。</p>
<p>我们的研究表明：</p>
<ol>
<li>Intel和AMD处理器上，可以自动检测某个MSR和对应的配置比特。我们引入了<strong>一个能够检测特殊比特的框架</strong>&mdash;<strong>MSRevelio</strong>，它能够自动检测影响指令行为的特殊比特，半自动检测BIOS设置中修改的特殊比特。</li>
<li>一些之前忽视的比特位，可以用来<strong>防御</strong>部分微架构攻击，比如Medusa, CrossTalk和软件预读取攻击</li>
<li>一个特定的undocumented比特位，能够在运行时关闭AES-NI，强制mbedTLS的AES部分“回退”到一个容易遭受缓存攻击的版本。在一个SGX enclave中利用这个“回退”，我们完整恢复了enclave使用AES密钥。</li>
<li>在对潜在漏洞进行公开陈述前，我们可以提前检测到用microcode更新的安全措施。</li>
<li>Xen对MSR的处理存在缺陷，游客能够访问undocumented和unhandled的MSRs，and fingerprint specific Xen versions。</li>
<li>Xen游客能够访问的一个undocumented的比特位，与CPU的时间戳计数器相关。基于此，我们实现了一种Foreshadow攻击。因此，对于那些和CPU经常交互的特性，透明度是很重要的。</li>
</ol>
<h2 id="1-intro">1. Intro<a aria-label="Link to this section" class="paige-header-link" href="#1-intro">#</a></h2>
<p>前三段，对MSR的用途、基于MSR的攻击、基于MSR的Mitigation的相关工作进行了介绍。</p>
<p>第四段，介绍一个自动化的检测工具&mdash;<a href="https://github.com/IAIK/msrevelio">MSRevelio</a>，检测MSRs，对其分类为documented, partly documented, undocumented三类，分析检测到的undocumented的MSR，使用概率分析来寻找undocumented MSR和documented MSR之间的相关性。</p>
<p>第五段，介绍基于 MSRevelio来半自动化检测不同的BIOS版本中，受到BIOS设置影响的MSR。并且给出了6个相关的安全case studies。</p>
<p>第六段，介绍MSR影响指令行为，可以用来mitigate一些攻击，也会造成一些安全问题。</p>
<p>第七段，针对不同的CPU microcode版本，作者发现可以提前检测到不同版本间的区别，知道厂商部署了什么安全措施。在漏洞和补丁，公开之前。</p>
<p>第八段，Xen使用一个block list来避免游客访问部分MSR，允许其访问剩余的所有MSR（已知的+未知的）。这造成两个问题，根据block list，攻击者可以迅速得到Xen的版本号，而且旧版本由于没有禁用新版本增加的MSR，游客使用旧版本的Xen可以潜在地访问host系统的那些安全相关的MSR。</p>
<p>第九段，MSR会直接影响到系统的安全性。如果用户能够修改某些MSR，那么他们很有可能可以使得一些mitigation失效。当然，使用MSR，也可以对一些软件层面的漏洞进行防御，比如prefetch-based攻击。我们建议对于那些处理器漏洞，应该用配置MSR来作为短期方案，之后在硬件层面进行解决。</p>
<p>第十段，就是说一下作者的贡献，主要都是摘要里面的“研究表明”部分。</p>
<h2 id="2-background">2. Background<a aria-label="Link to this section" class="paige-header-link" href="#2-background">#</a></h2>
<h3 id="a-model-specific-registermsr">A. Model Specific Register(MSR)<a aria-label="Link to this section" class="paige-header-link" href="#a-model-specific-registermsr">#</a></h3>
<p>MSR寄存器的地址为32位，大小为64位，使用两个特权指令<code>rdmsr</code>和<code>wrmsr</code>来读取和写入。</p>
<p>Hypervisor（虚拟化技术）通过限制可访问的MSR，避免guest系统控制host系统。</p>
<h3 id="b-intel-sgx">B. Intel SGX<a aria-label="Link to this section" class="paige-header-link" href="#b-intel-sgx">#</a></h3>
<p>Intel SGX是一个用来提供Intel CPU上的可信执行环境的指令集扩展，假定OS、管理员和特权软件都有可能被欺骗，执行恶意代码。所以，它把所有受信任的代码存储在一个特定的区域&mdash;<strong>enclave</strong>。enclave的程序运行在一个加密、被隔离的区域，从而OS和物理攻击这也没办法访问其内容。Intel认为，enclave出现漏洞，一定是因为enclave开发者本身的问题。或者是类似于条件竞争的软件bug。常规应用程序可以调用enclave，OS能够在任意时间点中断enclave。</p>
<h3 id="c-micro-op-performance-profiling">C. Micro-op Performance Profiling<a aria-label="Link to this section" class="paige-header-link" href="#c-micro-op-performance-profiling">#</a></h3>
<p>乱序执行的引入增加了CPU的复杂性，传统方法难以分析正在执行代码的实际行为，CPU厂商引入一些 <strong>Performance Monitor Counters(PMCs)</strong>，用于更精确地检测代码的执行过程，但是因为CPU还会把指令分解为微操作，所以PMC观测到的事件和指令难以进行对应。</p>
<p><a href="https://github.com/andreas-abel/nanoBench"><strong>NanoBench</strong></a>，可以解决上述问题，寻找到某个指令实际对应的PMCs。它能够<strong>减少外部影响</strong>（噪音），对指定的代码片段进行compile处理，并且<strong>使用一个已知的state来填满 CPU pipeline</strong>，为所有的测试过程提供相同的测试环境。也就是说，可以使用这个工具得到某条指令的实际行为。</p>
<h3 id="d-transient-execution-attacks">D. Transient-execution Attacks<a aria-label="Link to this section" class="paige-header-link" href="#d-transient-execution-attacks">#</a></h3>
<p>乱序执行和推测执行使得CPU会经历瞬态执行的一个阶段，收集微结构层次的痕迹，就可以泄露秘密信息。</p>
<h3 id="e-microcode">E. Microcode<a aria-label="Link to this section" class="paige-header-link" href="#e-microcode">#</a></h3>
<p>用于CPU的安全机制更新，是一个抽象层，位于实际的物理硬件和 Instruction Set Architecture之间。</p>
<h2 id="3-msrevelio">3. MSRevelio<a aria-label="Link to this section" class="paige-header-link" href="#3-msrevelio">#</a></h2>
<p>该机制的目的是找到影响系统安全性的undocumented MSR的比特位。</p>
<p>大致的工作流程为，扫描可能的MSR的地址空间（整个32bit的地址空间，两个十六进制数来表示），然后进行不断分类。</p>
<ol>
<li>read-only, write-only, read-writable
<ol>
<li>就是用rdmsr, wrmsr尝试读和写，看看会不会引发GPF中断错误</li>
</ol>
</li>
<li>documented, <strong>undocumented</strong>, <strong>partly documented</strong>
<ol>
<li>下载官方的document（PDF），开发一个PDF解析器，将检测到的MSR和官方文档的MSR进行自动对比</li>
</ol>
</li>
<li>Dynamic, static
<ol>
<li>Dynamic。进行cpu压力测试，观察undocument MSR bits和documented bits的相关性</li>
<li>static。通常为配置项，在相同环境下，反复执行某一个片段，修改其值，观察区别。</li>
</ol>
</li>
</ol>
<p>然后，修改BIOS的某一项配置，观察MSR的变化</p>
<h3 id="a-detecting-undocumented-msrs">A. Detecting Undocumented MSRs<a aria-label="Link to this section" class="paige-header-link" href="#a-detecting-undocumented-msrs">#</a></h3>
<p>该阶段对完整的32bit的地址空间进行扫描，完成前两项分类工作。</p>
<blockquote>
<p><strong>关于：GPF</strong></p>
</blockquote>
<p>一般保护错误，是一种错误或者说是，因为错误而被引发的中断。如果程序（用户程序或内核程序）违反了处理器的保护措施，会引发这个中断。一次的话，会关闭进程，告知用户；如果处理GPF过程中，引发二次GPF，会蓝屏；如果三次，会自动关闭处理器。</p>
<blockquote>
<p><strong>关于：SMM 模式</strong></p>
</blockquote>
<p>SMM mode，系统管理模式。它是intel引进的，对OS透明，操作系统完全不了解处理器什么时候进入了SMM mode，甚至不清楚处理器曾经进入过SMM mode。intel在CPU上增加一个管脚，其为高电平时，CPU进入PMM模式，屏蔽一切中断，只能在系统管理内存（SMRAM）执行SMM程序（只能由BIOS等硬件实现），只能通过执行RSM指令推出SMM模式。
在具体实现上，有一些需要注意的细节，作者在这一部分进行了列举。</p>
<blockquote>
<p>MSRevelio is implemented as a Linux kernel module with an additional user-space library. It uses the rdmsrl_safe and wrmsrl_safe kernel functions to catch GP faults when reading and writing MSRs.</p>
</blockquote>
<h3 id="b-classifying-msrs">B. Classifying MSRs<a aria-label="Link to this section" class="paige-header-link" href="#b-classifying-msrs">#</a></h3>
<blockquote>
<p>见A.设计的第三步</p>
</blockquote>
<p>该阶段完成第三项工作、第四项工作的前半部分：</p>
<ol>
<li>上面提到的分类工作的最后一项。dynamic, static
<ol>
<li>dynamic, 随着CPU，基本上一直在变。比如计数器、传感器的值</li>
<li>static, 基本上没什么变化，比如一些配置选项</li>
</ol>
</li>
<li>针对undocumented <strong>dynamic</strong> MSR bits，分析 undocumented MSR bit和documented MSR bit 之间的相关性
<ol>
<li>执行一个CPU的压力测试，记录这些MSR的<strong>归一化</strong>后的值</li>
<li>the Spearman and the Pearson coefficient来分析相关性</li>
</ol>
</li>
</ol>
<hr>
<p><a href="https://github.com/IAIK/msrevelio"><strong>项目地址</strong></a>，在实现的时候，clone下该仓库以后，进行以下三步：</p>
<ol>
<li>Building the tools
<ol>
<li>主要在 ./msr_scanner目录下</li>
<li>用管理员权限加载到kernel一个模块，具体来说，就是在./msr_scanner/<strong>modules</strong> 目录下，make一下，将生成的 <strong>msrs.ko</strong> 插入到 kernel modules 中
<ol>
<li><code>.ko</code>(kernel object)，比<code>.o</code>多了个kernel，可以加载到内核中的驱动模块</li>
</ol>
</li>
<li>./msr_scanner/<strong>tools</strong> 目录下，make一下，得到三个可执行文件
<ol>
<li><strong>msrs_detect</strong> - this can be used to trigger a scan</li>
<li><strong>msrs_ls</strong> - prints all found MSRs</li>
<li><strong>msrs_sample</strong> - can be used to sample MSR values</li>
</ol>
</li>
</ol>
</li>
<li>Run MSR detection
<ol>
<li>主要在 ./msr_scanner/<strong>tools</strong>/build/bin/ 目录下，运行一下 msrs_detect开始扫描，扫描结束后，使用msrs_ls将扫描结果存储在一个msrs.log文件内。</li>
</ol>
</li>
<li>Analyze MSR list
<ol>
<li>主要在 ./scripts/sampling 目录下。</li>
<li>运行一个sample_all.sh（调用上面生成的msrs_sample工具）</li>
<li>运行一个msrs_analyze.py，看看哪些MSR是随时间变化的。 绘图，寻找dynamic MSR之间的相关性。</li>
</ol>
</li>
</ol>
<hr>
<h3 id="c-impact-on-instruction-behavior">C. Impact on Instruction Behavior<a aria-label="Link to this section" class="paige-header-link" href="#c-impact-on-instruction-behavior">#</a></h3>
<p>该阶段完成第四项工作的后半部分，研究undocumented MSR bits对指令行为的影响（相同测试环境内，运行 a set of instructions），对<strong>undocumented static MSRs</strong>进行处理，因为波动的MSR bits一般不会成为 feature-control bits，<strong>配置选项</strong>。</p>
<p>但是，存在一个问题，就是我们如何确定，造成指令行为变化的MSR bits，是某一个MSR中单个反转了的bit，还是某个MSR中部分bits共同组成了一个配置选项。</p>
<blockquote>
<p>MSR寄存器的地址为32位，大小为64位</p>
</blockquote>
<p><strong>一般的方法是</strong>，针对每个MSR中可写的bits，迭代地反转每一个比特，毫无疑问，这样做，得出来的结果更加全面，但是工作量很爆炸。</p>
<p>因此，作者提出 <strong>optimized flipping masks</strong>（反转掩码，64比特长度，做异或进行反转）。他<strong>只考虑长度不大于 W 的比特组（可能的配置选项）</strong>，采用2^W^次的写入，遍历一遍，看看PMC的变化。当然，这样得出的结果是不全面的，但是具有更高的效率。</p>
<p>具体原因有两个：一个是工作量；另一个是作者假设，这些配置选项之间不存在相互影响。</p>
<blockquote>
<p>It is not beneficial to have one bit for enabling a feature and another for disabling it again.</p>
</blockquote>
<p><strong>实现：</strong> MSRevelio是基于nanoBench的，前文提到过，它对代码片段进行compile，杜绝外部影响，在构造的相同的测试环境中多次重复compile后的代码片段。</p>
<p>面对庞大的搜索空间，nanoBench需要调用的次数是极为频繁的，所以，MSRevelio基于 undocumented bits的行为，对其进行了三个阶段的预筛选。</p>
<ol>
<li>Phase 1: Detecting Writable Bits.
<ol>
<li>对所有undocumented MSR bits，尝试读出值，然后将反转后的值写入，再尝试读出值，看看反转是否成功。将结果记录下来</li>
<li>因为MSR bits的修改经常会造成系统故障，还要记录出一个blocklist of such MSRs。</li>
<li>该过程可以使用一个远程控制的power switch实现自动化（引用文献24）</li>
</ol>
</li>
<li>Phase 2: Initial Recording of the Changed States.
<ol>
<li>使用相同的 instruction groups ，测试长度不大于4比特的所有可能区域造成的影响。</li>
<li>假设：多个undocumented enum MSR fields对指令行为的影响是相互独立的。所以，该阶段作者没有控制变量，每次只测试一个enum MSR field，而是对一个MSR的所有可能enum MSR fields同时测试。
<ol>
<li>所以，才会有 i5-4570 中，177个MSR中共3612个undocumented writable bits，第一次测试，逐个MSR进行16次测试，也就是 177 x 16 = 2832次</li>
<li>找到特定的那个MSR之后，64个bit的空间，对于所有可能的enum MSR field，因为上一步已经测试了一部分（也就是从头到尾恰好16组），剩下的组不交叉的部分也可以同时测试。关于需要进行31 x 16 次数，这里有一个<strong>疑问</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>Phase 3: Finding the Origin of the Effects.
<ol>
<li>Phase 2后会得到一个对指令行为有明显影响的MSR的候选列表。</li>
<li>本阶段，针对候选项中的每一个MSR，顺序测试所有bit，从而将PMC观察到的影响和特定的enum字段进行对应。</li>
</ol>
</li>
</ol>
<p>![IA32_MCi_STATUS MSR](src/IA32_MCi_STATUS MSR.png)</p>
<hr>
<p>项目中相对应的<a href="https://github.com/IAIK/msrevelio/tree/master/msr_influences">介绍</a>，</p>
<hr>
<h3 id="d-results">D. Results<a aria-label="Link to this section" class="paige-header-link" href="#d-results">#</a></h3>
<p>我们在总共5个CPU上对未记录的MSR进行了彻底搜索。这些CPU的总体结果如表1所示。</p>
<p>我们在AMD和Intel CPU上发现了5890个未记录的MSR，其中大多数发现的MSR（4876）位于AMD CPU上。</p>
<p>然而，在AMD上发现的静态、可读可写、未记录的MSR中，96.8%在写入时不会引发GP错误，而是忽略写入值，从而限制了进一步的位行为分析。</p>
<p>我们也观察到54.1%的英特尔MSR有类似的行为。</p>
<p>我们分析了所有这些未记录的MSR与记录的MSRs的相关性。我们发现53个未记录的MSR暴露了与现有MSR相关的持续变化的值。例如，动态MSR（0x637）公开了一个与记录的计数器相关的单调计数器，我们在第V-F节中进一步探讨了这个计数器。</p>
<p>对于静态MSR，我们进行了enum字段搜索，以查找影响特定指令的位。我们发现1个未记录的位和6个部分记录的位影响cpuid和预取等指令。第五节分析了这些MSR位的影响。为了确定MSR的具体功能，需要手动分析。</p>
<h2 id="4-detecting-os-configurable-bios-features">4. Detecting OS-configurable BIOS features<a aria-label="Link to this section" class="paige-header-link" href="#4-detecting-os-configurable-bios-features">#</a></h2>
<p>本章节研究BIOS的设置会造成哪些 static MSRs发生变化。BIOS主要用于在boot时配置一些CPU的选项，比如采用哪些features，电源管理相关的。一些CPU的配置只能由BIOS在boot时设置，另一些选项能够由操作系统修改。许多BIOS版本仅向用户公开一小部分设置。MSLevelio模板化BIOS版本，以提示用户如何从操作系统重新启用解锁功能。此外，它还可用于分析未记录或描述不佳的BIOS功能是否会影响MSR。</p>
<h3 id="a-bios-templating">A. BIOS Templating<a aria-label="Link to this section" class="paige-header-link" href="#a-bios-templating">#</a></h3>
<p>提前准备一个 MSR列表和BIOS设置表，记录static MSR的初始值，尝试修改某一个 BIOS设置，观察这些 static MSR的值是否发生了变化。反复多次。</p>
<p>这里的static MSR bits包括 documented 和 undocumented。</p>
<h3 id="b-setup">B. Setup<a aria-label="Link to this section" class="paige-header-link" href="#b-setup">#</a></h3>
<p>评估了 5 个CPU，结果是发现了一些没有被官方文档记录的BIOS设置选项。</p>
<p>实现时，将所有BIOS设置为默认值，然后使用 MSRevelio来测试它是否可读、可写，然后更改特定设置，观察MSR的前后差异。</p>
<h3 id="c-results">C. Results<a aria-label="Link to this section" class="paige-header-link" href="#c-results">#</a></h3>
<p>1）Documented Settings</p>
<p>一些发现，比如其中一个MSR bit可以支持 fast-support string，从而防御 Medusa</p>
<p>2）Unofficial or Undocumented Settings</p>
<p>还有一个 0x7a 的MSR，有一个 bit 可以开启 Intel SGX。0x13c的MSR有一个bit可以用来关闭AES-NI</p>
<h2 id="5-case-studies">5. Case studies<a aria-label="Link to this section" class="paige-header-link" href="#5-case-studies">#</a></h2>
<p>本节介绍六个case，证明先前忽略的MSR位的安全影响。</p>

        
        
    </section>


    </div>
</article>














                        
                    </main>
                    





    <footer>
        
        
            <p class="text-center"><a class="link-secondary text-decoration-none" href="https://github.com/willfaught/paige">Paige Theme</a></p>
        
        
    </footer>


                </div>
            </div>
        </div>
        <script>
function paigeResize() {
    var e = document.querySelector('section[class="paige-content"]');
    if (!e) {
        return;
    }
    var mw = getComputedStyle(e).maxWidth;
    var w;
    if (mw === "100%") {
        var e = document.querySelector("body > div.container");
        var s = getComputedStyle(e);
        var px = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);
        var bx = parseFloat(s.borderLeftWidth) + parseFloat(s.borderRightWidth);
        w = e.offsetWidth - px - bx;
    } else {
        w = parseFloat(mw.substring(0, mw.length - 2));
    }
    var es = document.querySelectorAll('section[class="paige-content"] > div');
    for (var i = 0; i < es.length; i++) {
        var e = es[i];
        var iframe = false;
        for (var j = 0; j < e.children.length; j++) {
            if (e.children.item(j).tagName.toLowerCase() === "iframe") {
                iframe = true;
                break;
            }
        }
        if (iframe && e.style.width !== w) {
            e.style.width = w + "px";
        }
    }
}
paigeResize();
addEventListener("resize", paigeResize);

var paigeQuery = matchMedia("(prefers-color-scheme: dark)");
if (paigeQuery.matches) {
    document.documentElement.setAttribute("data-bs-theme", "dark")
}
paigeQuery.addEventListener("change", function (e) {
    if (e.matches) {
        document.documentElement.setAttribute("data-bs-theme", "dark");
    } else {
        document.documentElement.removeAttribute("data-bs-theme");
    }
});

</script>










    
    
    


<script  crossorigin="anonymous"   defer  integrity="sha256-yqyVgS/SWX6RGq388CazJ03XCi9wptdg&#43;EG8X0nYuIo="   referrerpolicy="no-referrer"  src="/bootstrap.bundle.min_16066188465625427804.min.caac95812fd2597e911aadfcf026b3274dd70a2f70a6d760f841bc5f49d8b88a.js"></script>













<noscript></noscript>

        
    </body>
</html>

<!-- Paige theme from https://github.com/willfaught/paige -->

